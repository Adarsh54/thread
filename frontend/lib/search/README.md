# Search integration (for partner: schema + seed)

This folder and the Search API implement **Search RPC**, **Embeddings**, **Search API**, and **Search page**. They are designed to plug into the schema and seed data you create.

## 1. Products table (you create)

Table name must match `SEARCH_CONFIG.productsTable` in `lib/search/config.ts` (default: `products`).

Columns used by the app and RPC:

| Column       | Type           | Notes                          |
|-------------|----------------|--------------------------------|
| `id`        | uuid (or text)  | Primary key                    |
| `name`      | text            |                                |
| `description` | text (nullable) | Used for embedding backfill  |
| `image_url` | text (nullable) |                                |
| `price`     | numeric (nullable) |                          |
| `category`  | text (nullable) | Optional filter in search      |
| `brand`     | text (nullable) | Shown on search result cards   |
| `source`    | text (nullable) | Optional product source       |
| `metadata`  | jsonb (nullable) |                                |
| `embedding` | vector(1536)   | OpenAI text-embedding-3-small  |

- Enable pgvector: `create extension if not exists vector;`
- Add embedding column: `alter table products add column embedding vector(1536);`
- Create an index for fast similarity search:  
  `create index on products using ivfflat (embedding vector_cosine_ops) with (lists = 100);`  
  (Tune `lists` after you have enough rows; rule of thumb: sqrt(row_count) up to a few hundred.)

## 2. RPC `match_products` (run after your table exists)

We provide `supabase/migrations/20250214_match_products_rpc.sql`. **Run it in the Supabase SQL Editor after your products table (and `embedding` column) exist.** It defines:

- `match_products(query_embedding, match_limit, match_threshold, filter_category)`
- Returns rows with: id, name, description, image_url, price, category, metadata, similarity

If your table or column names differ, either:

- Edit the migration to use your names, or  
- Update `lib/search/config.ts` (productsTable, embeddingColumn, matchProductsRpc) so the Search API and RPC stay in sync.

## 3. Checking that the schema is ready

After you’ve created the table and run the RPC migration, call:

- **GET `/api/search/health`** — Uses the Supabase client to call `match_products` with a zero vector. Returns `{ ok: true }` when the schema is ready, or `{ ok: false, error: "..." }` with details. Use this to verify integration (e.g. from a dashboard or CI).

## 4. Seed data and embeddings (backfill)

After inserting products, the `embedding` column must be filled. We provide:

- **`lib/embeddings`** — `getEmbedding(text)` for a single query; `getEmbeddings(texts[])` for batch (e.g. backfill).
- **`lib/search/backfill.ts`** — `computeEmbeddingsForBackfill(products: { id, text }[])` returns `{ id, embedding }[]` in batches. Your script can: (1) fetch products from Supabase, (2) map to `{ id, text: description ?? name }`, (3) call `computeEmbeddingsForBackfill`, (4) update each row’s `embedding` using the Supabase client (service role if needed).

Embedding model: **text-embedding-3-small** (1536 dimensions). If you use a different dimension, update the migration (vector size) and `SEARCH_CONFIG.embeddingDimension` in `lib/search/config.ts`.

## 5. Elasticsearch (semantic search for hackathon / production)

When **`ELASTICSEARCH_URL`** is set, the Search API uses **Elasticsearch kNN** for semantic search instead of Supabase pgvector.

- **Setup:** Create a cluster at [Elastic Cloud](https://cloud.elastic.co). Add `ELASTICSEARCH_URL` and `ELASTICSEARCH_API_KEY` to `.env.local`.

- **Embeddings: two options**
  - **OpenAI in the app:** Leave `ELASTICSEARCH_INFERENCE_ID` unset. The app uses `OPENAI_API_KEY` to embed queries and to backfill product embeddings in Supabase; sync copies those into ES.
  - **Elasticsearch Inference (no OpenAI in app):** Create an [inference endpoint](https://www.elastic.co/guide/en/elasticsearch/reference/current/inference-api.html) in your cluster (e.g. OpenAI text-embedding-3-small or another provider). Set **`ELASTICSEARCH_INFERENCE_ID`** to that endpoint ID. Query and product embeddings are then generated by ES; you don’t need `OPENAI_API_KEY` in the app for search or sync. The endpoint’s model must output **1536 dimensions** to match the index mapping (or change `SEARCH_CONFIG.embeddingDimension` and the index).

- **Index products:** **POST `/api/search/index`** syncs Supabase → Elasticsearch (auto-sync also runs on first search if the index is empty). With inference ID set, products don’t need an `embedding` column in Supabase; embeddings are generated during sync.
- **Search:** `POST /api/search` uses ES kNN when configured; otherwise it falls back to the `match_products` RPC (pgvector).

## 6. Env (for Search API and backfill)

- `OPENAI_API_KEY` — required for query embedding and for backfill. Add to `frontend/.env.local`.
- Supabase URL and anon key are already used by the Search API; backfill scripts can use the same or the service role key for updates.
- `ELASTICSEARCH_URL` (optional) — when set, semantic search runs on Elasticsearch; add `ELASTICSEARCH_API_KEY` if your cluster uses API key auth.
